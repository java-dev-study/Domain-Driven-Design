# 도메인 모델 시작하기

**1.1 도메인이란?**

1) `온라인 서점`을 개발자의 입장에서 바라보았을 때
> 온라인 서점 : 구현해야 할 소프트웨어의 대상\
> 상품 조회, 구매, 결제, 배송 추적 등 : 기능

→ `온라인 서점` : 소프트웨어로 해결하고자 하는 문제 영역, 즉 **도메인**

2) 도메인
- 한 도메인은 다시 하웨 도메인으로 나눌 수 있음 → 한 도메인은 여러 하위 도메인으로 구성
- 한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능 제공
> ex) 고객이 물건을 구매하면 주문, 결제, 배송, 혜택 하위 도메인의 기능이 엮이게 됨
- 특정 도메인을 위한 소프트웨어라고 해서 도메인이 제공해야 할 모든 기능을 직접 구현하는 것은 아님
> ex) 결제와 배송의 경우 외부 업체의 시스템 사용

---

**1.2 도메인 전문가와 개발자 간 지식 공유**
- 요구사항의 정확한 이해가 중요
- 요구사항을 잘못 이해하면 다시 변경하거나 만들어야 할 코드의 양이 많아짐
- 요구사항을 올바르게 이해하기 위한 방법 : 도메인 전문가와 개발자가 직접 대화
- Garbage in, Garbage out

---

**1.3 도메인 모델**
- 특정 도메인을 개념적으로 표현한 것
- 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움이 됨
- `객체 모델` : 기능과 데이터를 함께 보여 줌\
              → 도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야함
- `전이 모델링` : 상태 다이어그램 이용
- 그 외에도 그래프, 수학 공식 등을 이용해 모델링 가능

---

**1.4 도메인 모델 패턴**
1) 애플리케이션 아키텍쳐 구성
- 표현
> 1. 사용자의 요청을 처리하고 사용자에게 정보를 보여 줌
> 2. 사용자 = 소프트웨어를 사용하는 사람 & 외부 시스템
- 응용
> 1. 사용자가 요청한 기능을 실행
> 2. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행
- 도메인
> 시스템이 제공할 도메인 규칙을 구현
- 인프라스트럭처
> 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리

2) 앞장까지의 도메인 모델
- 도메인 자체를 이해하는 데 필요한 개념 모델
3) 1.4장의 도메인 모델
- 도메인 계증을 구현할 때 사용하는 객체 모델
- 아키텍처 상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴
- `도메인 계층` : 도메인의 핵심 규칙 구현
> ex) 주문 도메인 : 출고 전에 배송지를 변경할 수 있다 / 주문 취소는 배송 전에만 할 수 있다
- 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확정해야 할 때\
다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 됨

---

**1.5 도메인 모델 도출**
- 도메인 모델링 기본 작업 : 모델을 구성하는 핵심 구성요소, 규칙, 기능 찾기
- `어떤 데이터`로 구성되는지 알려 주는 규칙
> 1. 한 상품을 한 개 이상 주문할 수 있다.
> 2. 각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.

└ OrderLine : 주문할 상품, 상품의 가격, 구매 개수를 포함해야 함
- 도메인과 하위 도메인의 관계를 알려 줌
> 3. 최소 한 종류 이상의 상품을 주문해야 한다.
> 4.총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.

└ Order와 OrderLine과의 관계를 알려 줌
- 제약과 규칙
> 5. 출고를 하면 배송지 정보를 변경할 수 없다.
> 6. 출고 전에 주문을 취소할 수 있다.

- 상태
> 7. 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다

---

**1.6 엔티티와 밸류**
- 도출한 모델 = 엔티티(Entity) + 밸류(Value)

1) 엔티티
- 엔티티 객체마다 고유한 `식별자`를 가짐
> ex) 주문 도메인에서 `주문번호`는 각 주문마다 서로 다름
- `식별자`는 바뀌지 않음
> ex) 주문에서 배송지 주소나 상태가 바뀌어도 주문번호는 바뀌지 않음
- 엔티티를 생성하고 속성을 바꾸고 삭제할 때가지 `식별자`는 유지
- 두 엔티티 객체의 식별자가 같으면 **두 엔티티는 같음**

2) 엔티티의 식별자 생성
- 생성 시점은 도메인의 특징과 기술에 따라 달라짐
- 식별자 생성 방법
> 1. 특정 규칙에 따라 생성 : `현재 시간과 다른 값 조합`
> 2. UUID나 Nano ID와 같은 고유 식별자 생성기 사용 : `java.util.UUID 이용`
> 3. 값을 직접 입력 : `회원 아이디, 이메일 등 / 중복해서 입력하지 않도록 사전 방지 필요`
> 4. 일련번호 사용 : `시퀀스나 DB의 자동 증가 컬럼 사용`\
> └ 자동 증가 컬럼 사용 시 DB에 데이터를 삽입해야 값을 알 수 있음 → 엔티티를 생성할 때 식별자를 넘길 수 없음을 의미\
> `cf) 리포지터리 : 도메인 객체를 데이터베이스에 저장할 때 사용하는 구성요소`

3) 밸류 타입
- 개념적으로 완전한 하나를 표현할 때 사용
- 꼭 두 개 이상의 데이터를 가져야 하는 것은 아님
- 의미를 명확하게 표현하기 위해 밸류 타입을 사용하는 경우도 있음
- 밸류 타입을 위한 기능 추가 가능
- 데이터를 변경할 때는 기존 데이터를 변경하기보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 방식 선호 : **불변**

4) 엔티티 식별자와 밸류 타입
- 식별자를 위한 밸류 타입을 사용해서 의미가 잘 드러나도록 할 수 있음
ex) int 대신 Money 사용

5) 도메인 모델에 set 메서드 넣지 않기
- set 메서드는 도메인의 핵심 개념이나 의돌르 코드에서 사라지게 함
> ex) `changeShippingInfo()` → `setShippingInfo()` : 배송지 정보를 변경한다는 의미 → 단순히 배송지 값 설정
- 도메인 객체를 생성할 때 온전하지 않은 상태가 될 수 있음 → `생성자`를 통해 필요한 데이터를 모두 받아야 함
- 불변 밸류 타입을 사용하게 되면 자연스럽게 set 메서드를 구현하지 않음

---

**1.7 도메인 용어와 유비쿼터스 언어**
```java
public OrderState {
  STEP1, STEP2, STEP3, STEP4, STEP5, STEP6
}
```
- 실제 주문 상태 : 결제 대기 중 → 상품 준비 중 → 출고 완료됨 → 배송 중 → 배송 완료됨 → 주문 취소됨
- 위 코드를 통해 아래와 같은 코드가 작성되면 도메인 규칙이 드러나지 않음 : STEP1과 STEP2인지만 검사할 뿐
```java
public class Order {
  public void changeShippingInfo(ShippingInfo newShippingInfo) {
    verifyStep1OrStep2();
    setShippingInfo(newShippingInfo);
  }
  
  private void verifyStep1OrStep2() {
    if (state != OrderState.STEP1 && state != OrderState.STEP2) {
      throw new IllegalStateException("already shipped");
    }
  }
}
```
- 다음과 같이 수정
```java
public enum OrderState {
  PAYMENT_WAITIN, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED;
}
```
- `유비쿼터스 언어` : 전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고\
이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어 사용
- 도메인에 알맞는 영단어를 찾는 것도 추후 불필요한 해석 과정을 줄일 수 있음
