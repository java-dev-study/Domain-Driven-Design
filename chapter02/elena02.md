## 아키텍처 개요

**1. 네 개의 영억**
- 표현, 응용, 도메인, 인프라스트럭처
- 표현 영역
> 1. HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달
> 2. 등용 용역의 응답을 HTTP 응답으로 변환하여 전송

- 응용 영역
> - 시스템이 사용자에게 제공해야 할 기능 구현\
> ex) 주문 등록, 주문 취소, 상품 상세 조회 등
> - 기능 구현을 위해 도메인 영역의 도메인 모델 사용
> - 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위힘

- 도메인 영역
> - 도메인 모델을 구현

- 인프라스트럭처 영역
> - 구현 기술에 대한 것을 다룸
> - RDBMS 연동을 처리, 메시징 큐에 메시지를 전송하거나 수신, 몽고DB나 레디스와의 데이터 연동을 처리
> - SMTP를 이용한 메일 발송 기능 구현
> - REST API 호출 처리

---

**2. 계층 구조 아키텍처**
- 상위 계층에서 하위 계층으로의 의존만 존재
- 하위 계층은 상위 계층에 의존하지 않음
- 구현의 편리함을 위해 유연하게 적용하기도 함\
→ `응용 계층은 바로 아래의 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라스트럭처 계층에 의존하기도 함`
- 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 종속
- 인프라스트럭처에 의존하면 `테스트 어려움`과 `기능 확장의 어려움`이 있음 → **DIP**를 통해 해결

---

**3. DIP**
- `고수준 모듈` : 의미 있는 단일 기능을 제공하는 모듈
- `저수준 모듈` : 하위 기능을 실제로 구현한 것
- `고수준 모듈`이 동작하려면 `저수준 모듈`을 사용해야 하는데, 구현 변경과 테스트가 어렵다는 문제가 있음
- `DIP(의존 역전 원칙)` : 위 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꿈 → **추상화 인터페이스**
- 구현 기술 교체 문제 해결 : 구현을 추상화한 인터페이스에 의존하여 실제 사용할 저수준 구현 객체는 의존 주입을 이용하여 전달받는 것이 가능
- 테스트 어려움 문제 해결 : 저수준 모듈이 만들어지기까지 기다리지 않고 대역 객체 사용하여 테스트 가능
- 아키텍처
> 1. 아키텍처에 DIP를 적용하면 인프라스트럭처 영역이 응용 영ㅇ역과 도메인 영역에 의존(상속)하는 구조가 됨
> 2. 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능

---

**4. 도메인 영역의 주요 구성요소**
- 엔티티, 밸류, 애그리거트, 리포지터리, 도메인 서비스
1) 엔티티와 밸류
- 도메인 모델의 엔티티
> - 데이터와 함께 도메인 기능을 제공\
> (도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화하여 데이터가 임의로 변경되는 것을 막음)
> - 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현 가능

2) 애그리거트
- 도메인 모델이 복잡해지면 개발자는 한 개 엔티티와 밸류에만 집중하는 상황이 발생
- 관련 객체를 하나로 묶은 군집 (ex) 주문)
- 군집에 속한 객체를 관리하는 루트 엔티티를 가짐\
`cf) 루트 엔티티 : 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능 제공`
- 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화

3) 리포지터리
- RDBMS, NoSQL, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관하기 위한 도메인 모델
- 구현을 위한 도메인
- 애그리거트 단위로 도메인 객체를 저장하고 조히
- 응용 서비스는 의존 주입과 같은 방식을 사용해서 실제 리포지터리 구현 객체에 접근
> (1) 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용\
> (2) 응용 서비스는 트랜잭션을 관리한느데, 트랜잭션 처리는 리포지터리 구현 기술의 영향을 받음
- 응용 서비스가 필요로 하는 메서드 제공
> 기본 메서드\
> (1) 애그리거트를 저장하는 메서드\
> (2) 애그리거트 루트 식별자로 애그리거트를 조회하는 메서드\
> (3) 필요에 따라 delete(id)나 counts() 메서드

---

**5. 요청 처리 흐름**
1. 사용자가 애플리케이션에 기능 실행 요청
2. `표현 영역`에서 요청을 처음 받음
3. 사용자가 전송한 데이터 형식이 올바른지 검사하고 문제가 없다면 데이터를 이용해 `응영 서비스`가 요구하는 형식으로 변환하여 전달하며 기능 실행 위힘

└ 웹 브라우저를 이용해 기능 실행 요청 → 컨트롤러가 요청 파라미터를 응용 서비스가 필요로 하는 데이터로 변환하여 전달
`ex) Spring Framework를 사용한다면 @Transactional 이용하여 트랜잭션 처리`
```java
public class CancelOrderService {
  private OrderRepository order Repository;
  
  @Transactional  //응용 서비스는 트랜잭션을 관리
  public void cancel(OrderNumber number) {
    Order order = orderRepository.findByNumber(number);
    if (order == null) throw new NoOrderException(number);
    order.cancel();
  }
  ...
}
```

---

**6. 인프라스트럭처 개요**
- 표현, 응용, 도메인 영역을 지원
- 다른 영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원
- `DIP`를 통해 무조건 의존을 없앨 필요는 없음

---

**7. 모듈 구성**
- 애그리거트 기준으로 패키지 구성
- 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니도록
