### Chapter03 애그리거트



#### 3.1 애그리거트

- 애그리거트는 관련된 객체를 하나의 군으로 묶어줌
- 복잡한 도메인을 단순한 구조로 만들어 도메인 기능을 확장하고 변경하는데 수월함
- 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 가짐
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않음
- 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높음



#### 3.2 애그리거트 루트

- 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티로 애그리거트가 제공해야 할 도메인 기능을 구현함
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경해서는 안됨
- 이는 애그리거트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 됨
- 도메인 모델에 대해 다음의 두 가지를 습관적으로 적용해야함
  - set 메서드를 공개(public) 범위로 만들지 않음
  - 밸류 타입은 불변으로 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성할 수 있음
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야함
- 만약, 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 응용 서비스에서 두 애그리거트를 수정해야함



#### 3.3 리포지터리와 애그리거트

- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재함
- 어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받음
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야함
- 리포지터리가 완전한 애그리거트를 제공하지 않으면 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NullPointerException 문제가 발생할 수 있음
- 애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야함



#### 3.4 ID를 이용한 애그리거트 참조

- 애그리거트 간의 참조는 필드를 통해 쉽게 구현 가능
- 애그리거트를 직접 참조할 때 발생할 수 있는 문제
  - 편한 탐색 오용
  - 성능에 대한 고민
  - 확장 어려움
- 위의 문제를 개선하기 위해 애그리거트를 참조할 때 ID를 사용함
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결됨
- ID 참조 방식을 사용하면 N+1 조회와 같은 문제가 발생할 수 있는데, 조회 전용 쿼리를 사용하여 개선할 수 있음



#### 3.5 애그리거트 간 집합 연관



#### 3.6 애그리거트를 팩토리로 사용하기

- 도메인 기능을 응용 서비스에서 구현해서는 안됨

- 애그리거트를 팩토리로 사용할 경우 도메인의 응집도가 높아짐