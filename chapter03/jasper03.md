## 3.1 애그리거트

- 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는 데 도움이 된다
- 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다
- 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미한다
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트다
- 수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다
- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다
    - 도메인 규칙에 따라 최초 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다
- 애그리거트는 경계를 갖는다
    - 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다
    - 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다
    - 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다
    - 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다
- 'A가 B를 갖는다'로 해석할 수 있는 요구사항이 있다고 하더라도 이것이 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다
- 처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만, 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다
- 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많으며, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다


## 3.2 애그리거트 루트

- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다
- 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다

### 3.2.1 도메인 규칙과 일관성

- 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 
    - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다
        - 도메인의 의미나 의도를 표현하지 못하고 도메인 로직을 도메인 객체가 아닌 응용 영역이나 표현 영역으로 분산 시킨다
        - 의미가 드러나는 메서드를 사용해서 구현하자
    - 밸류 타입은 불변으로 구현한다

### 3.2.2 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다, 기능 실행을 위임하기도 한다
    - 애그리거트 외부에서 해당 기능을 실행하여, 버그가 생기지 않도록 해야 한다

### 3.2.3 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋다
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다
    - 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생한 가능성이 더 높아지기 때문에 전체 처리량이 떨어지게 된다
- 한 애그리거트에서 다른 애그리거트를 변경하지 않는다
    - 애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하는 꼴
- 애그리거트는 최대한 서로 독립적이어야 하는데 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아진다


## 3.3 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재
- 리포지토리는 보통 두 메서드를 기본으로 제공한다
    - save : 애그리거트 저장
    - findById : ID로 애그리거트를 구함
    - 이 외에도 필요에 따라 다양한 조건으로 애그리거트를 검색하는 메서드나 애그리거트를 삭제하는 메서드를 추가할 수 있다
- 레거시 DB를 사용하거나 팀 내 DB 설계 표준을 따라야 한다면 DB 테이블 구조에 맞게 모델을 변경해야 한다


## 3.4 ID를 이용한 애그리거트 참조

- 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조한다
- 필드를 이용한 애그리거트 참조는 다음 문제를 야기할 수 있다
    - 편한 탐색 오용
        - 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다 -> 한 애그리거트가 관리하는 범위는 자기 자신으로 한정
        - 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높인다
    - 성능에 대한 고민
        - 지연(lazy)로딩과 즉시(eager)로딩
    - 확장 어려움
- ID를 이용해서 다른 애그리거트를 참조하면 위의 문제를 완하할 수 있다
    - 한 애그리거트에 속한 객체들만 참조로 연결
    - 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춤 -> 응집도 증가
    - 구현 복잡도 감소
    - 애그리거트별로 다른 DB 기술을 사용할 수 있음


## 3.5 애그리거트 간 집합 연관


## 3.6 애그리거트를 팩토리로 사용하기

- 도메인 로직 처리가 응용 서비스에 노출되면 안된다
- 응용 서비스 영역은 변경 용이하게 개발하자
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해 보자
- 팩토리 메서드