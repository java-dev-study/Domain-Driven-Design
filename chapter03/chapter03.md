## 3.1 애그리거트

- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 애그리거트이다.

- 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.

- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.

- 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.

#
## 3.2 애그리거트 루트

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 애그리거트의 루트 엔티티이다.

- 3.2.1 도메인 규칙과 일관성

  - 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현

  - 밸류타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하므로 애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 일관성을 올바르게 유지할 수 있다.

- 3.2.2 애그리거트 루트의 기능 구현

  - 애그리거트의 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성

- 3.2.3 트랜잭션 범위

  - 트랜잭션 범위는 작을수록 좋다.
  
  - 한 트랙잭션에서 한 애그리거트만 수정해야 한다. 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 높아진다.

- 3.3 리포지터리와 애그리거트

  - 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재

  - 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.

- 3.4 ID를 이용한 애그리거트 참조

  - 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조하는 것이다.

  - ORM 기술 덕에 애그리거트 루트에 대한 참조를 쉽게 구현할 수 있다.

  - 다른 애그리거트의 참조는 다른 애그리거트의 상태를 쉽게 변경할 수 있는데, 의존 결합도를 높이지 않기 위해서 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.

  - 하위 도메인 별 시스템을 분리하고 도메인마다 서로 다른 DBMS를 사용할 때 DB테이블에서 외래키로 참조하는 것과 비슷하게 ID를 이용해 참조를 한다.

  - ID를 통한 간접참조는 복잡도를 낮추는 장점과 다른 애그리거트를 수정하는 문제를 근원적으로 방지할 수 있다.

- 3.4.1 ID를 이용한 참조와 조회 성능

  - ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만드는 데 지연 로딩과 관련된 대표적인 문제가 N+1 문제이다.

  - 조회를 위한 별도 DAO를 만들어 조회 전용 쿼리를 사용(join)하여 N+1 문제를 해결

  - 쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야 한다면 조회를 위한 부분만 마이바티스와 같은 기술을 이용해서 구현할 수 있다.

  - 한 대의 DB 장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 캐시나 조회 전용 저장소를 활용

#
## 3.5 애그리거트 간 집합 연관

- 애그리거트 간 1-N 관계는 Set과 같은 컬렉션을 이용해서 표현. 하지만 성능 문제 때문에 애그리거트 간의 1-N 연관을 실제 구현에 반영하지 않음.

- M-N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.

- JPA를 이용하면 매핑설정을 사용해 ID참조를 이용한 M-N 단방향 연관을 구현

#
## 3.6 애그리거트를 팩토리로 사용하기

- 도메인 기능을 응용 서비스에서 구현하면 안된다.

- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 기능을 구현하는 방식도 고려

- 애그리거트의 생성과 동시에 중요한 도메인 로직을 함께 구현할 수 있다.