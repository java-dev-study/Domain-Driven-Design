## 3.1 애그리거트

애그리거트? 상위 수준에서 모델을 조망할 수 있는 방법 
- 상위수준에서 모델이 어떠헥 엮여 있는지 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 모델에 반영할 수 있다.
- 일관성을 관리하는 기준이 된다.
- 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
- 도메인 규칙에 따라 함꼐 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 애그리거트가 한개의 엔티티 객체만 갖는 경우가 많다.

## 3.2 애그리거트 루트

애그리거트에 속한 모든 객체가 정상 상태를 가져아 함

루트 엔티티? 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티다. 

도메인 규칙과 일관성? 
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는것  -> 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야함.
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안됨 -> 이것은 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.
- 단순히 필드를 변경하는 set 메서드를 public 범위로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다. 

애그리거트 루트의 기능 구현?
애그리거트 루트의 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다. 
보통 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 protected 범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지할 수 있다. 

트랜잭션 범위?
작을수록 좋다. 
한 트랜잭션에서는 한 개의 애그리거트만 수정 해야한다. 
애그리거트는 최대한 서로 독립적이어야한다. -> 결합도가 높아지면 높아질수록 향후 수정 비용이 증가하므로 애그리거트에서 다른 애그리거트의 상태를 변경하지 말아야 한다.

예외 경우?
- 팀표준인 경우
- 기술적 제약이 있는 경우
- UI 구현의 편리함이 더 중요한 경우

## 3.3 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한개의 도메인 모델을 표현하므로, 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재 함

리포지터리는 보통 다음 메서드을 기본으로 제공
- save : 애그리거트 저장
- findById : ID로 애그리거트 구함

애그리거트는 개념적으로 하나이므로, 리포지터리는 애그리거트 전체를 저장소에 영속화한다.

## 3.4 ID를 이용한 애그리거트 참조
애그리거트도 다른 애그리거트를 참조한다.

필드를 이용한 애그리거트 참조는 편한 탐색 오용, 성능에 대한 고민, 확장 어려움등 어려움을 야기할 수 있다.

ID를 이용한 참조와 조회 성능?
ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만드는 데 지연로딩과 관련된 대표적인 문제가 N+1 조회 문제이다.
이 문제가 발생하지않도록 하려면 조인을 사용하거나, 조회 전용 쿼리를 사용하면됨

## 3.5 애그리거트 간 집합 연관
애그리거트 간 1-N관계는 Set과 같은 컬렉션을 이용해서 표현할 수 있다. 
M-N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다.

## 3.6 애그리거트를 팩토리로 사용하기

- 중요한 도메인 로직 처리는 응용 서비스에 노출되면 안됨
- 애그리거트를 팩토리로 사용할 때 얻을 수 있는 장점? 
-> 도메인의 응집도가 높아진다
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.
