## 애그리거트

**1. 애그리거트**
- 상위 수준 개념을 이용해서 전체 모델 정리 → 전반적인 관계 이해에 도움
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위 수준에서 모델을 조망할 수 있는 방법
- 관련된 객체를 하나의 군으로 묶음
- 상위 수준에서 도메인 모델 간의 관계 파악 가능
- 일관성을 관리하는 기준
- 한 `애그리거트`에 속한 객체는
> 1. 유사하거나 동일한 라이프 사이클을 가짐
> 2. 다른 애그리거트에 속하지 않음

- 독립된 객체 군
- `도메인 규칙`과 `요구사항`은 경계 설정 시 기본이 되는 것

---

**2. 애그리거트 루트**
- `애그리거트`는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 됨
- `애그리거트 루트 엔티티` : 애그리거트에 속한 모든 객체가 일관된 상태를 유지하기 위해 애그리거트 전체를 관리하는 주체, 애그리거트의 대표 엔티티

1) 도메인 규칙과 일관성
- 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현\
`ex) 주문 애그리거트 : 배송지 변경, 상품 변경 등의 기능 / 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공`

- 애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현
- 애그리거트 외부에서 애그리거트에 속한 객체 직접 변경 불가능\
→ `애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인`

- 불필요한 중복 피하기 & 애그리거트 루트를 통해서만 도메인 로직 구현
> 1. 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
> 2. 밸류 타입은 불변으로 구현한다.

2) 애그리거트 루트의 기능 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성
- 기능 실행을 위임하기도 함
- 한 애그리거트에 속하는 모델은 한 패키지에 속함\
→ 패키지나 protected 범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것 방지 가능

3) 트랜잭션 범위
- 작을수록 좋음
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함\
→ 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 높아지기 때문
- 애그리거트는 최대한 서로 독립적이어야 함
- 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 응용 서비스에서 두 애그리거트를 수정하도록 구현
- 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려해야 하는 경우
> 1. `팀 표준` : 팀이나 조직의 표준에 따라 사용자 유스케이스과 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우
> 2. `기술 제약` : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 함
> 3. `UI 구현의 편리` : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것\
→ 한 트래잭션에서 여러 주문 애그리거트의 상태 변경

---

**3. 리포저티러와 애그리거트**
- `리포지터리` : 객체의 영속성을 처리, 애그리거트 단위로 존재
- 기본 제공 메서드
> 1. save : 애그리거트 저장
> 2. findById : ID로 애그리거트를 구함
>
> `→ 새로운 애그리거트를 만들면 저장소에 애그리거트를 영속화하고 애그리거트르 사용하려면 저장소에서 애그리거트를 읽어야 하기 때문`

- 리포지터리를 구현할 때 사용하는 기술에 따라 애그리거트의 구현도 영향을 받음
- 애그리거트 전체를 저장소에 영속화해야 함
- 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 함\
`→ 완전한 애그리거트를 제공하지 않으면 NullPointerException 등 발생 가능`

- **RDBMS**를 이용하여 리포지터리를 구현하면 트랜잭션을 이용해서 애그리거트의 변경이 저장소에 반영되는 것을 보장할 수 있음

---

**4. ID를 이용한 애그리거트 참조**
- 애그리거트도 다른 애그리거트를 참조 == 다른 애그리거트의 루트를 참조
- 필드를 통해 구현 가능
- JPA : @ManyToOne, @OneToOne → 연관된 객체를 로딩하는 기능을 제공하고 있으므로 필드를 이용해 다른 애그리거트를 쉽게 참조 가능
- 필드를 이용한 애그리거트 참조를 사용하면 다른 애그리거트의 데이터 쉽게 조회 가능
- 필드를 이용한 애그리거트 참조의 문제점
> 1. 편한 탐색 오용
> 2. 성능에 대한 고민
> 3. 확장 어려움

- `ID를 이용한 참조` : 위에서 언급한 세 가지 문제를 완화할 때 사용할 수 있는 것
- **ID 참조**
> 1. 모든 객체가 참조로 연결되지 않음
> 2. 한 애그리거트에 속한 객체들만 참조로 연결됨
> 3. 모델의 복잡도를 낮춤
> 4. 애그리거트 간의 의존을 제거하므로 응집도를 높여 줌
> 5. 구현 복잡도도 낮아짐
> 6. 애그리거트별로 다른 구현 기술을 사용하는 것도 가능해짐

1) ID를 이용한 참조와 조회 성능
- 다른 애그리거트를 ID로 참조하면 참조하는 애그리거트를 읽을 때 조회 속도가 문제 될 수 있음
- `N+1 조회 문제` : 조회 대상이 N개일 때 N개를 읽어오는 한 번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행\
→ `조인`을 사용하여 해결 가능하나 이는 객체 참조 방식으로 다시 되돌리는 것\
→ `조회 전용 쿼리`를 하용하면 ID 참조 방식을 사용하면서 N+1 조회 문제 해결 가능

---

**5. 애그리거트 간 집합 연관**
- 애그리거트 간 `1-N과 M-N 연관` : `컬렉션`을 이용한 연관
- `1-N 관계` : Set과 같은 컬렉션을 이용해 표현 가능
- `M-N 관계` : 양쪽 애그리거트에 컬렉션으로 연관을 만듦

---

**6. 애그리거트를 팩토리로 사용하기**
- 장점 : 도메인 로직을 변경해도 응용 서비스는 영향을 받지 않으며 도메인의 응집도가 높아짐
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 할 때 고려
