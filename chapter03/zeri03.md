## 3장. 애그리거트

<br>
<br>

### 3-1. 애그리거트
***
상위 수준에서 모델이 어떻게 엮여 있는지 알아야 전제 모델을 망가뜨리지 않으면서 푸가 요구하상을 모델에 반영할 수 있음  
  
복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트  
  
수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 도멜 간의 관계를 파악할 수 있음  
  
한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않음. 애그리거트는 독립된 객체 군이며 각 애그리거트는 자신 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다
  
경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항

<br>
<br>

### 3-2. 애그리거트 루트
***
- 주문 애그리거트
    - 총 금액인 totalAmounts를 갖고 있는 Order 엔티티
    - 개별 구매 상품 개수인 quantity와 금액인 price를 갖고 있는 OrderLine 밸류

구매할 상품의 개수를 변경하면 OrderLine의 quantity를 변경하고 더불어 Order의 TotalAmounts도 변경해야함

  
__그렇지 않으면 도메인 규칙을 어기고 데이터 일관성이 깨진다__
  
애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다. 도메인 규칙을 지치켜렴 애그리거트에 속한 모든 객체가 정상 상태를 가져야한다.   
  
애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다. 애그리거트 루트 엔티티는 애그리거트의 대표 엔티티이다. 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.   

<br>

  - 애그리거트 루트(Order)
    - OrderLine
    - ShippingInfo
    - Orderer
  
<br>

 도메인 모델에 관해 두 가지를 습관적으로 적용해야함
 - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다
 - 밸류 타입은 불변으로 구현한다

<br>
  
애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다  
  
- 트랙잭션 범위
  - 작을수록 좋다
  - 한 트랙잭션에서는 한 개의 애그리거트만 수정해야한다
  - 한 트랙잭션에서 두 개 이상의 애그리거트를 수정해야한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현


- 한 트랙잭션에서 두 개 이상의 애그리거트를 변경해도 좋은 경우
  - 팀 표준 : 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랙잭션으로 실행해야하는 경우
  - 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랙잭션에서 다수의 애그리거트를 수정해서 일관성으로 처리해야함
  - UI 구현의 편리 : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트 상태를 변경해야 함



<br>
<br>


### 3-3. 리포지토리와 애그리거트
***
애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지토리는 애그리거트 단위로 존재함  
리포지토리는 애그리거트 전체를 저장소에 영속화함

<br>
<br>

### 3-4.ID를 이용한 애그리거트 참조
***
애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있음  
주문 애그리거트에 속해 있는 Orderer는 주문한 회원을 참조하기 위해 회원 애그리거트 루트인 Member를 필드로 참조할 수 있음   
  
- 필드를 이용한 애그리거트 참조의 문제점 
    - 편한 탐색 오용
    - 성능에 대한 고민
    - 확장 어려움
    - N + 1 문제가 발생할 수 있음


__해결법 : ID를 이용해서 다른 애그리거트를 참조하는 것__

  
애그리거트마다 서로 다른 저장소를 사용하번 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다. 이때 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전ㅇ용 저장소를 따로 구성한다. 이는 코드가 복잡해지는 단점이 있지만 시스테므이 처리량을 높일 수 있다는 장점이 있다. 특이 한 대의 DB장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 캐시나 조회 전용 저장소는 필수로 선택해야하는 기법이다. 

<br>
<br>


### 3-5. 애그리거트 간 집합 연관
***
애그리거트 간 1-N, M-N 연관. 예를 들면 카테고리와 상품과의 연관관계

<br>
<br>



### 3-6. 애그리거트를 팩토리로 사용하기
***
애그리거트가 갖고 있느 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해 볼 것

<br>
<br>
