## CQRS

**1. 단일 모델의 단점**
- 조회 기능의 경우 속도가 빠를수록 좋은데 여러 애그리거트의 데이터가 필요하면 구현 방법 고민 필요\
→ 식별자를 이용해서 애그리거트를 참조할 경우 `즉시 로딩(eager loading)` 방식과 같은 JPA의 쿼리 관련 최적화 기능 사용 불가능\
→ `직접 참조` 방식을 사용해도 `연관도 즉시 로딩`이나 `지연 로딩(lazy loading)`으로 처리해야 하기 때문에 고민 필요

- 위와 같은 고민이 발생하는 이유 → 시스템 상태를 변경할 때와 조회할 때 `단일 도메인 모델`을 사용하기 때문
- `ORM 기법` : 도메인 상태 변경 기능 구현엔 적합하지만 여러 애그리거트에서 데이터를 가져와 출력하는 기능은 구현 복잡도 ↑
- 구현 복잡도를 낮추기 위해선 `상태 변경을 위한 모델`과 `조회를 위한 모델`을 분리하는 것

---

**2. CQRS**
- 시스템 제공 기능 : `상태 변경 기능`과 `사용자 입장에서 상태 정보 조회 기능`
- 도메인 모델 관점에서 `상태 변경 기능` : 주로 한 애그리거트의 상태를 변경
- 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않음\
→ 단일 모델로 두 종류의 기능 구현 시 불필요하게 복잡해짐\
→ 위 문제를 해결할 수 있는 방법 : `CQRS`
- Command Query Responsibility Segregation\
→ 상태를 변경하는 `명령(Command)`을 위한 모델과 상태를 제공하는 조회(Query)를 위한 모델을 분리하는 패턴
- 복잡한 도메인에 적합
- 각 모델에 맞는 구현 기술 선택 가능
- 상태 변경을 위한 `명령 모델`은 객체를 기반으로 한 도메인 모델을 이용해서 구현
- 같은 구현 기술을 사용할 수도 있음
- `명령 모델`과 `조회 모델`이 서로 다른 데이터 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있음

1. 웹과 CQRS
- 일반적인 웹 서비스 : 상태를 변경하는 요청보다 상태를 조회하는 요청이 多
- 조회 성능을 높이기 위해 다양한 기법을 사용하는 것 == `CQRS`를 적용하는 효과
- 대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 적용
- 조회 속도를 높이기 우해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분\
→ 조회 기능 때문에 명령 모델이 복잡해지는 것 방지 가능\
→ 명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 보다 쉽게 적용 가능

2. CQRS 장단점\
`장접`
- 명령 모델을 구현할 때 도메인 자체에 집중 가능
- 명령 모델에서 조회 관련 로직이 사라져 복잡도 ↓
- 조회 성능을 향상시키는 데 유리\
→ 조회 단위로 캐시 기술 적용 가능\
→ 저장소를 사용하면 조회 처리량 대폭 늘리기 가능

　
`단점`
- 구현해야 할 코드가 더 많음\
→ 단일 모델을 사용할 때 발생하는 복잡함 때문에 발생하는 구현 비용과 조회 전용 모델을 만들 때 발생하는 구현 비용 따져봐야 함
- 더 많은 구현 기술이 필요\
→ 명령 모델과 조회 모델을 다른 구현 기술을 사용해서 구현하기도 함\
→ 경우에 따라 다른 저장소를 사용하기도 함\
→ 데이터 동기화를 위해 메시징 시스템을 도입해야 할 수도 있음
