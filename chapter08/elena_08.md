## 애그리거트 트랜잭션 관리

**1. 애그리거트와 트랜잭션**
- 운영자와 고객이 동시에 한 주문 애그리거트를 수정할 때
- 트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로\
운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 됨
- 운영자 스레드와 고객 스레드는 개념적으로 동일하지만 물리적으로 서로 다른 애그리거트 객체를 사용
- 두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DB에 반영
→ 애그리거트의 일관성이 깨질 수 있음

`방지하기 위한 방법`
1. 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못 하게 막기
2. 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 함

- 자체 트랜잭션과 관련이 있음
- 트랜잭션 처리 방식 : `선점 잠금`과 `비선점 잠금`

---

**2. 선점 잠금**
- Pessimistic Lock
- 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지\
다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식
1. 스레드1이 선점 잠금 방식으로 애그리거트를 구한 뒤 이어서 스레드2가 같은 애그리거트를 구함
2. 스레드2는 스레드1이 애그리거트에 대한 잠금을 해제할 때까지 Blocking 됨
3. 스레드1이 애그리거트를 수정하고 트랜잭션을 커밋하면 잠금을 해제
4. 대기하고 있던 스레드2가 애그리거트에 접근
5. 스레드1이 트랜잭션을 커밋한 뒤에 스레드2가 애그리거트를 구하게 되므로 스레드2는 스레드1이 수정한 애그리거트의 내용을 보게 됨

→ 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에\
애그리거트를 수정할 때 발생하는 데이터 충돌 문제 해소

- 보통 DBMS가 제공하는 `행단위 잠금`을 사용해서 구현
- 오라클 : for update와 같은 쿼리를 사용해서 특정 레코드에 한 커넥션만 접근할 수 있는 잠금장치 제공
- JPA EntityManager : LockModeType을 인자로 받는 find() 메서드 제공
- 스프링 데이터 JPA : `@Lock` Annotation을 사용해서 잠금 모드를 지정
　
 
1. 선점 잠금과 교착상태
- `선점 잠금`을 사용할 때는 잠금 순서에 따른 `교착 상태`가 발생하지 않도록 주의
- `선점 잠금`에 따른 `교착 상태`는 상대적으로 사용자 수가 많을 때 발생할 가능성 ↑
- 사용자 수가 많아지면 교착 상태에 빠지는 스레드는 더빠르게 증가

`방지하기 위한 방법`
- 잠금을 구할 때 최대 대기 시간을 지정해야 함
- JPA : `선점 잠금`을 시도할 때 최대 대기 시간을 지정하려면\
↓
```java
Map<String, Object> hints = new HashMap<>();
hints.put("javax.persistence.Lock.timeout", 2000);
Order order = entityManager.find(Order.class, orderNo, LockModeType.PESSIMISTIC_WRITE, hints);
```

- `java.persistence.lock.timeout` : 잠금을 구하는 대기 시간을 밀리초 단위로 지정
- 스프링 데이터 JPA : `@QueryHints` Annotation을 사용해서 쿼리 힌트 지정 가능

---

**3. 비선점 잠금**
- 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식
- `비선점 잠금`을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티 추가
- 애그리거트를 수정할 때마다 버전으로 사용할 프로퍼티 값이 1씩 증가\
→ `UPDATE aggtable SET version = version + 1, colx = ?, coly = ? WHERE aggid = ? and version = 현재버전`
- JPA : 버전을 이용한 `비선점 잠금` 기능 지원\
→ 버전으로 사용할 필드에 `@Version` Annotaion 작성 & 매핑되는 테이블에 버전을 저장할 컬럼 추가
```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
 @EmbeddedId
 private OrderNo number;
 
 @Version
 private long version;
 ...
}
```

└ 엩니니가 변경되어 UPDATE 쿼리를 실행할 때 `@Version`에 명시한 필드를 이용해서 `비선점 잠금 쿼리`를 실행

- `응용 서비스`는 버전에 대해 알 필요 X
- 쿼리 실행 결과로 수정된 행의 개수가 0이면 이미 앞서 데이터가 수정된 것\
→ 트랜잭션이 충돌한 것이므로 트랜잭션 종료 시점에 Exception 발생
- `표현 영역` 코드는 이 Exception이 발생했는지에 따라 트랜잭션 충돌이 일어났는지 확인 가능
- 사용자가 전송한 버전과 애그리거트 버전이 동일한 경우에만 애그리거트 수정 기능을 수행하도록 하여 트랜잭션 충돌 문제 해소 가능
- `비선점 잠금 방식`을 여러 트랜잭션으로 확장하려면 애그리거트 정보를 뷰로 보여줄 때 버전 정보도 함께 사용자 화면에 전달
- `표현 계층`은 버전 충돌 Exception이 발생하면 버전 충돌을 사용자에게 알려 사용자가 알맞은 후속 처리를 할 수 있도록 함

`cf. Spring Framework : OptimisticLockingFailureException / 응용 서비스 코드 : VersionConflictException`

1. 강제 버전 증가
- 애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버전 값이 증가해야 `비선점 잠금`이 올바르게 동작한다는 점에서\
`JPA`는 애그리거트 관점에서 문제가 됨
- `EntityManager#find()` 메서드로 문제 처리 가능

---

**4. 오프라인 선점 잠금**
- 한 트랜잭션 범위에서만 적용되는 `선점 잠금 방식`이나 나중에 버전 충돌을 확인하는 `비선점 잠금 방식`은\
다른 사용자가 수정 중일 때 수정 자체를 못 하도록 막는 기능을 구현할 수 없음\
→ 이때 필요한 것이 `오프라인 선점 잠금 방식(Offliine Pessimistic Lock)`
- 여러 트랜잭션에 걸쳐 동시 변경을 막음

1. 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스
- `오프라인 선점 작금` : 잠금 선점 시도, 잠금 확인, 잠금 해제, 잠금 유효시간 연장 기능 必
- `LockManager` : 위 기능을 위한 인터페이스
- 잠금을 선점하는 데 실패하면 `LockException`이 발생

2. DB를 이용한 LockManager 구현
- type과 id column을 PK로 지정해 동시에 두 사용자가 특정 타입 데이터에 대한 잠금을 구하는 것을 방지
