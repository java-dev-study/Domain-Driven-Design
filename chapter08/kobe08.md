# 8. 에그리거트 트랜잭션 관리

### 에그리거트와 트랜잭션

한 주문 애그리거트에 대해 운영자가 배송 상태로 변경할 때 사용자가 배송지 주소를 바꾸면 어떻게 될까?

하나의 트랜잭션 마다 리포지터리는 새로운 애그리거트 객체를 생설하기 때문에 운영자 스레드와 고객 스레드는 같은 주문 애그리거트를 나타내는 다른 객체를 구하게 된다.

운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트지만, 물리적으로 서로 다른 애그리거트 객체를 사용한다. 그렇게 때문에 운영자가 스레드와 고객 스레드는 서로 상이하기 때문에 서로에게 영향을 주지 않는다.

스레드는 트랜잭션을 커밋할 때 DB에 반영하게 되는데, 이러한 이유로 애그리거트의 일관성이 깨지게 된다.

일관성 문제를 깨지지 않게 하기 위해서, 두 가지 중 하나를 해야한다.

- 운영자가 배송지 정보를 조회하고, 상태를 변경하는 동안, 고객이 애그리거트를 수정 못하게 막는다.
- 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.

위 두 가지 방법은 애그리거트 자체의 트랜잭션과 관련이 있는데, DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다. - 선점, 비선점

### 선점 잠금

선점 잠금이란, 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식. - 스레드 1이 에그리거트를 구하게 되면, 에그리거트 2는 잠금을 해제할 때까지 블로킹된다. 스레드 1이 에그리거트를 수정하고 트랜잭션을 커밋 하면 그 때 잠금을 해제하고, 대기하고 있던 스레드2가 에그리거트에 접근하게 된다.

배송지 변경의 예를 대입했을 때 운영자가 선점 잠금 형식으로 애그리거트를 구하면 운영자가 잠금을 해제할 때 까지 고객 스레드는 대기 상태가 된다. 운영자가 배송 상태를 변경하고 트랜잭션을 커밋하면 잠금을 해제한다.

그 이후 고객이 애그리거트를 구하게 되면 이미 배송상태이므로, 배송지를 변경할 수 없다.

선점 잠금은 보통 DBMS가 제공하는 해당 단위 잠금을 사용해서 구현한다. JPA EntityManager은 LockModeType을 인자로 받는 find() 메서드를 제공한다. 

```jsx
Order order = entityManager.find(Order.class,orderNo,LockModeType.PESSIMISTIC_WRITE)
```

```jsx
@Lock(LockModeType.PESSIMISTIC_WRITE)
```

**8.2.1 선점 잠금과 교착 상태**

 선점 잠금 기능을 사용할 때는 잠금 순서에 따른 교착 상태가 발생하지 않도록 주의해야한다. 

EX) 

1. 스레드1 : A 애그리거트에 대한 선점 잠금 구함
2. 스레드2 : B 애그리거트에 대한 선점 잠금 구함
3. 스레드1 : B 애그리거트에 대한 선점 잠금 시도
4. 스레드2 : A 애그리거트에 대한 선점 잠금 시도

해당 예는 교착 상태에 빠진다. 스레드의 선점 잠금을 구한 다른 스레드가 선점 잠금을 시도했기 때문.

선점 잠금에 따른 교착 상태는 사용자 수가 많을 때 발생한다. 사용자 수가 많아지게 되면 스레드는 더 빠르게 증가하고, 시스템은 아무것도 할 수 없는 상태가 된다. → 교착 상태의 시간을 제한해줘야함

```jsx
eX) Spring Data JPA, @QueryHints 
```

### 비선점 잠금

선점 잠금이 강력해 보이긴 하지만, 선점 잠금으로 모든 트랜잭션 충돌 문제가 해결 되는 것은 아니다.

1. 운영자는 배송을 위해 주문 정보를 조회, 시스템은 정보 제공
2. 고객이 배송지 변경을 위해 변경 폼을 요청한다. 시스템은 변경 폼을 제공
3. 고객이 새로운 배송지를 입력하고 폼을 전송하여 배송지를 변경
4. 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경을 요청

여기에서 문제는 운영자가 배송지 정보를 조회하고 배송 상태로 변경하는 사이에 고객이 배송지를 변경한다.

즉 배송지를 한 번 더 확인해야하는 작업이 필요해진다. → 선점 잠금의 한계

이럴 때 필요한 것이 비선점 잠금이다. 비선점 잠금은 동시에 접근한는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.

비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야한다.

애그리거트를 수정할 때 마다 버전으로 사용할 프로퍼티 값이 1씩 증가하는데 이때 다음과 같은 쿼리를 사용한다.

```jsx
Update aggtable SET version = version+1, colx=?,coly=?
where aggid = ? and version = 현재 버전
```

위 쿼리를 이용해서 수정할 애그리거트와 매핑 되는 테이블의 버전 값이 현재 애그리거트의 버전과 동일한 경우에만 데이터를 수정한다. 이후 수정이 완료하면 버전 값을 1 증가시켜 수정 값이 다르면 수정에 실패하게 된다.

JPA에서는 @Version을 이용하여 비선점 잠금 기능을 지원한다.

@Version을 이용해서 응용 서비스는 버전에 대해 알 필요 없이 비선점에 대한 버전 관리를 할 수 있게 된다.

기능 실행 과정에서 애그리거트 데이터가 변경되면 JPA는 트랜잭션 종료 시점에 비선점 잠금을 위한 쿼리를 실행한다. 비선점 잠금을 위한 쿼리를 실행할 때 쿼리 실행 결과로 수정 된 행의 개수가 0이면 이미 누군가 앞서 데이터를 수정한 것이다. → 트랜잭션 충돌

버전으로 인한 트랜잭션 문제를 표현 영역에서 해결할 수 있는데 hidden input 값에 version을 넣어서 같이 서버에 전달할 수 있도록 한다. 

비선점 잠금과 관련된 버전 충돌 문제는, 명시적 구분이 필요 없다면 프레임워크용 익셉션을 발생시키자.

루트 외의 애그리거트를 바꿔 버전을 올리기 애매하다면, JPA 의 EntityManager#find() 메서드로 잠금 필요.

### 오프라인 선점 잠금

컨플루언스 문서를 편집할 때 누군가 편집을 하는 중이면 안내 문구를 보여준다. → 충돌 방지.

컨플루언스는 수정을 막는 경우가 아니기 때문에 누군가 수정 중이면 아예 수정을 막는 것이 필요하다. 
(비선점, 선점)은 한 트랜잭션 범위에서만 적용되기 때문에 이러한 경우는 구현이 힘들다.

이때 필요한 것이 오프라인 선점 잠금 방식이다.

수정 기능은 두 가지 트랜잭션으로 구성된다.

- 폼을 보여준다.
- 데이터를 수정한다.

오프라인 선점 잠금을 사용하면 폼 요청 과정에서 잠금을 선점하고, 수정 과정에서 잠금을 해제한다.

이미 잠금을 선점한 상태에서 다른 사용자가 폼을 요청하면 잠금을 할 수 없어 에러 화면을 확인하게 된다.

사용자가 데이터를 수정하는 과정에서 수정을 하지 않고 종료하면 어떻게 될까? 잠금을 해제하지 않아 

선점 해제를 할 수 없게 된다. → 오프라인 선점 잠금에서는 유효 시간이 필요.

오프라인 선점 잠금을 위한 LockManager Interface