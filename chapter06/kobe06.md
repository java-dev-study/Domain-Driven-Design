# 6. 응용 서비스와 표현 영역

### **6.1 표현 영역과 응용 영역**

도메인이 제 기능을 하려면 사용자와 도메인을 연결해주는 매개체가 필요하다. 응용 영역과 표현 영역이 사용자와 도메인을 연결해 주는 매개체 역할을 한다.

표현 영역은 사용자의 요청을 해석한다. 사용자가 웹 브라우저에서 폼에 ID와 암호를 입력한 뒤에 전송 버튼을 클릭하면 요청 파라미터를 포함한 HTTP 요청을 표현 영역에 전달한다. 요청 받은 표현 영역은 URL, 요청 파라미터, 쿠키, 헤더등을 이용해서 사용자가 실행하고 싶은 기능을 판별하고, 그 기능을 제공하는 응용 서비스를 실행

실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치. 
(회원 가입을 제공하는 주체는 응용 서비스에 위치한다.) 응용 서비스는 기능을 실행하는 데 필요한 입력 값을 메서드 인자로 받고 실행 결과를 리턴한다.

응용 서비스와 표현 서비스 간의 파라미터 형식이 맞지 않은 경우가 많기 때문에, 객체를 생성 후 메서드를 호출한다.  EX) JSON

이러한 이유 때문에 응용 서비스는 사용자가 REST API를 사용하는지 TCP 소켓을 사용하는지 알 필요가 없다.
그냥 실행 결과만 리턴하면 됌.

### **6.2 응용 서비스의 역할**

응용 서비스는 사용자(클라이언트) 가 요청한 기능을 실행한다.

응용 서비스는 사용자의 요청을 처리하기 위해 리포지터리에서 도메인 객체를 가져와 사용한다.

(응용 서비스는 사용자 입장에서 보았을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 창구 역할)

응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다.

응용 서비스가 도메인 로직을 일부 구현하면 코드 중복, 로직 분산 등 코드 품질에 안 좋은 영향을 줄 수 있다.

응용 서비스는 트랜잭션 처리도 담당. → 데이터의 일관성을 유지해야한다.

고메인 로직은 도메인 영역에 위치하고, 응용 서비스는 도메인 로직을 구현하지 않는다.

EX)

```java
public class Member {

  public void changePassword(String oldPw, String newPw) {
    if(!machPassword(oldPw)) throw new BadPasswordException();
    setPassword(newPw);
  }

  public boolean matchPassword(String pwd) {
    return passwordEncoder.matches(pwd);
  } -> O

  

////////////////////////////////////////////////////////////////

public class ChangePasswordService {

  public void changePassword(String memberId, String oldPw, String newPw) {
    Member member = memberRepository.findById(memberId);
    checkMemberExists(member);
    
    if(!passwordEncoder.matches(oldPw, member.getPassword())) {
      throw new BadPasswordException();
    }
    
    member.setPassword(newPw);
  }

}  -> X 기존 암호를 올바르게 입력함은 도메인의 핵심 로직이기 때문에 도메인 단에서 구현해야한다.
 
```

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.

- 코드의 응집성이 떨어진다.
    
    코드가 도메인, 서비스 영역에 있으면 도메인도 확인해야하고 서비스 쪽도 확인해야하기 때문에 분석해야할 영역이 많아진다.
    
- 여러 응용 서비스에서 동일한 코드 발생 (중복 코드)
    
    암호 확인하는 기능이 서비스 마다 있다고 하자 EX) 비밀번호 변경, 정지된 아이디 해제, 로그인
    그럼 서비스 마다 로그인 기능이 3개 도메인에 있으면 한 번 가능
    

일부 도메인 로직이 응용 서비스에 출현하면서 발생하는 두 가지 문제는 코드 변경을 어렵게 만든다.
소프트웨어가 가져야 할 중요한 경쟁 요소 중 하나는 변경 용이성인데, 변경이 어렵다는 것은 소프트웨어의 가치가 떨어진다는것을 의미한다. → 도메인 로직을 도메인 영역에 모아서 코드 중복을 줄이고 응집도를 높여야한다.

(도메인 로직이 뭘까) 

### **6.3 응용 서비스의 구현**

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 facade와 같은 역할을 한다. 

> 퍼사드란?
> 
> 
> 세탁기를 예로 들어보면 사용자는 세탁을 할 때 옵션을 조절할 수는 있지만 최종적으로는 동작 버튼 하나만 누르면 세탁기가 세탁 과정, 헹굼 과정, 탈수 과정을 자동으로 진행합니다.
> 
> 사용자가 직접 서브 시스템인 세탁 과정을 실행하고, 끝나면 헹굼 과정, 또 끝나면 탈수 과정을 직접 진행하지 않습니다. 동작  버튼 하나만 누르면 시스템이 해당 서브 시세템들을 자동으로 실행시켜 주는 것처럼, 복잡한 서브 시스템들을 인터페이스로 감싸서 사용하기 쉽게 만드는 것이 바로 '퍼사드 패턴(Pacade Pattern)'입니다.
> *(실무에서는 XXXFacade와 같이 퍼사드 패턴이 사용되었음을 따로 명시하지 않고 Service 형태로 많이 이용됩니다.)*
> 

응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 응용 서비스의 구현은 어렵지 않다. 
응용 서비스를 구현 할 때 필요한 몇 가지 고려 사항과 트랜잭션과 같은 구현 기술의 연동에 대해 살펴보자.

응용 서비스 자체의 구현은 어렵지 않지만 응용 서비스의 크기를 생각해야한다.

회원 도메인을 생각해 볼때 응용 서비스는 회원가입하기, 회원 탈퇴하기, 회원 암호 변경하기, 비밀번호 초기화 하기를 가질 수 있다. 이러한 경우 두 가지 방법으로 구현한다.

- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기

- 한 클래스 구현

```java
public class MemberService {

  private MemberRepository memberRepository;
  
  public void join(~~~) 
  
  public void changePassword(~~~) 
  
  public void initializePassword(~~~) 
 
  public void leave(~~~) 

	private Member findExistingMember(String memberId) {
	    Member member = memberRepository.findById(memberId);
	    if (member == null) 
      throw new NoMemberException(memberId);
	    return member;
  
}
```

한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 있어 코드 중복을 제거할 수 있다.

하지만 이렇게 한 클래스에 다 담게 된다면 한 서비스 클래스의 코드 줄 수가 길어져서, 연관성이 없는 코드가 같이 위치해 코드를 이해하는데 방해가 된다. 

추가로 한 클래스에 코드가 모이기 시작하면 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로넣어 코드 품질을 낮추는 결과를 초래함.

이러한 문제를 해결하기 위해서, 구분되는 기능별로 서비스 클래스를 구현하는 방식은 한 응용 서비스 클래스에 한 개 내지 2~3개의 기능 구현한다.

EX)  public void changePassword(~~~)  메소드를 ChangePasswordService와 같이 클래스로 선언

이러한 방식으로 클래스는 많아지지만, 클래스 별로 필요한 객체만 사용하기 때문에, 다른 코드에 영향을 주지 않는다.

각 기능 마다 동일한 로직을 사용하게 된다면 , import를 사용해서 구현하도록 하자.

한 클래스는 하나의 역할만 담당할 수 있도록 하나의 기능은 별도의 서비스 클래스로 구현하도록 하자.

- 인터페이스, 클래스

응용 서비스를 구현할 때 논쟁이 될 만한 것이 인터페이스가 필요한가이다.

인터페이스는 구현 클래스가 여러개인 경우에 필요로한다. 하지만 응용 서비스의 경우 구현 클래스가 두 개인 경우도 드물다.

이러한 이유로 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조가 복잡해진다.

TDD를 즐겨하고 표현 계층 구현을 선호하면 인터페이스를 사용하게 되지만, Mockito와 같은 테스트 도구를 사용해서 인터페이스의 필요성을 약화시킬 수 있다.

응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터로 전달 받아야 한다.

파라미터를 따로 따로 받을 수 있고, (id, password ,..), 객체 형식으로 한 번에 받을 수도 있다. (LoginDto)

응용 서비스는 해당 파라미터를 전달 받아서 필요한 기능을 구현하기만 하면 된다.

스프링과 같은 웹 프레임워크는 요청 파라미터를 자바 객체로 변환하는 기능이 있으니 DTO를 사용하는것이 편하다. 응용 서비스의 결과를 표현 영역에서 사용해야 하면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴한다.

에그리거트를 통째로 보내는 경우도 있는데, 

```java
<a th:href = "@{/order/~/{ordNO}(ordNO = ${order.number})}
```

이렇게 도메인 자체를 보내게 되면 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다.

이것은 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이된다.

→ 응용 서비스는 표현 영역에서만 필요한 데이터를 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다.

**표현 영역에 의존하지 않기**

응용 서비스에는 표현 영역과 관련된 타입을 사용하면 안된다. EX) HttpServletRequest나 HttpSession을 응용 서비스에 파라미터로 전달하면 안된다.
응용 영역에서 표현 영역 부분의 상태를 변경하게 된다면 표현 영역의 상태가 어떻게 변하는지 추적하기가 힘들어지기 때문에, 표현 영역 기술을 응용영역에서 사용하면 안된다.

**트랜잭션 처리하기**

회원가입, 주소 변경과 같이 롤백하지 않으면 원하는 서비스를 제공하지 못하게 되는 기능은 스프링 @Transaction 과 같은 어노테이션을 활용하여 트랜잭션 처리를 하도록 해야한다.

### **6.4 표현 영역**

표현 영역의 책임은 크게 다음과 같다.

- 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어한다.
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.
- 사용자의 세션을 관리한다.

(화면 제공, 세션 유지, 응용 서비스에게 잘 전달.)

### **6.5 값 검증**

값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행 할 수 있다. 원칙적으로는 응용 서비스에서 값 검증을 실행해야하는데, Form 영역에서 잘못 처리되어 다시 Form을 리턴해야한다면 계속해서 Form을 리턴해주는 코드를 추가해줘야한다. → 번잡한 코드 발생.

그리고 응용 서비스에서 에러를 잡아낸다면 해당 부분에서 에러를 표시하게 된다. 

EX) ID 비밀번호 둘 다 틀렸는데, ID에서 해당 에러를 잡아낸다면 ID 에러만 return 하게 된다.

- 사용자는 ID만 틀리다 생각할 수 있다.

이러한 불편을 해소하기 위해서 error 목록을 ValidationError 리스트를 생성하여 한꺼번에 알려주는 방법이 있다. 응용 영역과 표현 영역 두개를 활용하여 사용자의 잘못된 입력을 알려주는 경우도 있지만.

- 표현 영역 : 필수 값, 값의 형식 범위 검증
- 응용 서비스 : 데이터 존재 유무와 같은 논리적 오류 검증

응용 서비스에서 모든 검증을 다 하는 방법도 있다. 코드가 길어지는 단점이 있지만, 응용 서비스의 완성도가 높아지는 이점도 있다.

### **6.6 권한 검사**

사용자 U가 F라는 기능을 실행할 수 있는지를 확인하는 것이 권한 검사이다.

복잡한 개념이 아닌 권한 검사는 스프링 시큐리티와 같은 프림워크를 이용하여 유연하고 확장 가능한 구조를 가지고 있는데 유연한 만큼 복잡하다고 설명할 수 있다. 복잡한 권한 검사는 개발할 시스템에 맞게 적용하는 것이 중요하다.

권한 검사는 다음 세 곳에서 수행할 수 있다.

- 표현 영역
    
     인증된 사용자인지 아닌지를 검사하는 간단한 검사. (회원 정보 변경 기능)
    ex) URL을 처리하는 컨트롤러에 웹 요청을 전달하기 전에 인증 여부를 검사해서 인증된 사용자의 웹 요청만 컨트롤러에 전달한다.
     인증된 사용자가 아닐 경우 로그인 화면으로 리다이렉트 시킨다. (서블릿 필터)
    
- 응용 서비스

URL로 접근 제어를 할 수 없는 경우 응용 서비스의 메서드 단위로 검사를 수행해야한다.
AOP의 @PreAuthorize

- 도메인

개별 도메인 객체 단위로 권한 검사를 해야하는 경우는 구현이 복잡해진다.
(게시글 삭제의 예 경우 게시글 작성자를 확인하기 위해 에그리거트를 먼저 로딩해야한다. )

! 스프링 시큐리티와 같은 보안 프레임워크를 확장해서 개별 도메인 객체 수준의 권한 검사 기능을 프레임워크에 통합할 수 있다. 도메인 객체 수준의 권한 검사 로직은 도메인별로 다르기 때문에, 높은 이해가 필요하고 이해가 떨어진다면 도메인에 맞는 권한 검사 기능을 직접 구현하는것이 좋다.