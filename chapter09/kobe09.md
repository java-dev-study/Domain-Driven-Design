# 9.도메인 모델과 바운디드 컨텍스트

### 도메인 모델과 경계

처음 도메인 모델을 만들 때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다. 한 도메인은 다시 여러 하위 도메인으로 구분되기 떄문에 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 하면 오히려 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.

상품이라는 모델을 다양한 의미를 가진다. (재고 관리에서 상품, 주문에서 상품, 배송에서 상품,,)
카탈로그에서 한 개의 상품이 물리적으로는 여러 개일 수 있다. (후드티 정보는 한 개, 판매는 ~~개)

논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다. 
( 회원 ≠ 주문자 ≠ 보내는 사람 )

이렇게 하위 도메인마다 같은 용어라도 의미가 다르고, 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며, 표현도 불가능

하위 도메인마다 사용하는 용어가 달라 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야한다.

각 모델은 명시적으로 구분 되는 경계를 가져서 섞이지 않도록 해야한다. 
모델은 특정한 컨텍스트 하에서 완전한 의미를 갖는다. 이렇게 구분되는 경계를 갖는 컨텍스트를 바운디드 컨텍스트라고 한다. 

### 바운디드 컨텍스트

바운디드 컨텍스트는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 용어를 기준으로 ,논리적으로 한개의 모델을 갖는다. 카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할 수 있다. ( 카탈로그 컨텍스트 ≠ 재고 컨텍스트 )

바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 바운디드 컨텍스트 안에서 도메인을 구현한다.

이상적으로 하위 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋겠지만 현실은 그렇지 않을 때가 많다.

바운디드 컨텍스트는 기업의 팀 조직 구조에 따라 결정되기도 한다. 
(온라인 쇼핑몰을 하나의 팀에서 구현하고, 여러 하위 도메인을 한 개의 바운디드 컨텍스트에서 구현)

전체 하위 도메인을 위한 단일 모델을 만들지 말고, 개별 하위 도메인을 만들어서 하위 도메인별로 기능 확장을 보다 수월하게 하도록 진행하자. (한 개의 바운디드 안에서 여러 하위 도메인을 포함하게 되더라도, 하위 도메인 별 구분되는 패키지를 가지도록 구현해야한다.) 같은 “사용자의 의미를 가지는 컨텍스트라도” 연관 구분이 명확해진다.

### 바운디드 컨텍스트 구현

바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니다. 바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현영역, 응용 서비스, 인프라 스트럭처 영역을 모두 포함한다. 도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 테이블도 바운디드 컨텍스트에 포함된다.

표현 영역은 사용자에게 HTML, REST API 형식을 제공할 수 있다. 모든 바운디드 컨텍스트를 도메인 주도로 개발할 필요는 없다. 상품의 리뷰는 복잡한 도메인 로직을 가지고 있지 않기 때문에 CRUD 형식을 구현해도 된다. 
즉 DAO와 데이터 중심의 밸류 객체를 이용해서 리뷰 기능을 구현해도 된다. 
서비스 -DAO 구조를 사용하면, 도메인 기능이 서비스에 포함되지만, 간단하면 가능하다 판단.

한 바운디드에서 두 방식을 혼합해서 사용할 수 있는데, 대표적인 예가 CQRS 패턴.

CQRS는 상태를 변경하는 명령 기능과 ,내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴

(조회 전용 데이터는 서비스-DAO)

각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수 있고, 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것은 아니다. 상품의 상세 정보를 보여주는 페이지를 생각했을 때  HTML, JSON 형식 따로 응답할 수 있고, UI서버를 퍼사드로 이용하여 응답을 제공할 수 있다.

### 바운디드 컨텍스트 통합

온라인 쇼핑 사이트에서 카탈로그 하위 도메인에 개인화 추천 기능을 도입하여 기존 시스템에 추천 담당하는 별도의 팀이 작업을 하여, 카탈로그 바운디드와 추천 바운디드 컨텍스트로 구별되었다고 가정하자.

두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다.

카탈로그와 추천 바운디드 컨텍스트 간 통합이 필요한 기능은 다음과 같다.

- 사용자가 제품 사에 페이지를 볼 때 보고 있는 상품과 유사한 상품을 목록 하단에 보여준다.

! 카탈로그 시스템은 추천 시스템으로 부터 추천 데이터를 받아오지만, 카탈로그 시스템에서는 추천 도메인 모델을 사용하기 보다는 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야한다. 

→ ProductId id 값을 가져와서 카탈로그에서 보여줘야한다.

```jsx
List<Product> getRecommendationsOf(ProductID id);
```

도메인 서비스를 구현한 클래스는 인프라스트럭처 영역에 위치한다. 

REST API로 부터 데이터를 읽어와 카탈로그 도메인에 맞는 상품 모델로 변환하는 RecSystemClient 의 toPrdoucts() , 변환이 복잡하다면, 변환 처리를 위한 별도의 클래스르 만들어 처리해도 된다.

REST API를 호출하는 것은 두 바운디드 컨텍스트를 직접 통합하는 방법이다. 
직접 통합하는 대신 간접적으로 통합하는 방법도 있는데, 대표적인 간접 통합 방식 “메시지 큐” 

카탈로그 바운디드 컨텍스트 - (이력을 메시지 형식으로 큐에 추가) → 메시지 시스템  ← (큐에서 메시지 가져옴) - 추천 바운디드 컨텍스트 

어떤 도메인 관점에서 모델을 사용하느냐에 따라 두 바운디드 컨텍스트의 구현 코드가 달라지게 되는데, 카탈로그 도메인 관점에서 큐에 저장할 메시지를 생성하면 카탈로그 시스템의 연동 코드는 카탈로그 기준의 데이터를 그대로 메시지 큐에 저장 → 추천은 카탈로그 기준의 메시지를 자신에 맞게 저장해야함

(두 바운디드 컨텍스트를 개발하는 팀은 메시징 큐에 담을 데이터 구조를 협의하는데, 누가 제공하냐의 따라서 달라짐.) 큐를 이용해서 제공할경우 큐를 통해 메시지를 추천 시스템에 전달하는 방식이된다. 

### 바운디드 컨텍스트 간 관계

바운디드 컨텍스트는 어떤 식으로 든 연결 되기 떄문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 가진다. 

두 바운디드 컨텍스트 간 관계 중 가장 흔한 관계는 한쪽에서 API를 제공 한 쪽은 호출 하는 관계.

(API를 사용하는 바운디드 컨텍스트는 API를 제공하는 바운디드 컨텍스트에 의존하게 된다.)

하류 컴포넌트인 카탈로그 컨텍스트는 상류 컴포넌트인 추천 컨텍스트가 제공하는 데이터와 기능에 의존한다.
추천 시스템이 제공하는 REST API의 인터페이스가 바뀌면 카탈로그 시스템의 코드도 바뀐다.

상류 컴포넌트는 하류 컴포넌트가 사용할 수있는 통신 프로토콜을 정의하고 공개한다

EX) 추천 시스템은 하류 컴포넌트가 사용할 수 있는 REST API를 제공하거나 프로토콜 버퍼와 같은 것을 이용해서 서비스를 제공할 수 있다. 
상류 팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다. 이런 서비스를 가리켜 공개 호스트 서비스라고 한다. 공개 호스트 서비스 → 블로그, 카페, 게시판 검색

두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다. 운영자 주문과 고객의 주문과 같이 두 팀이 공유하는 모델을 공유 커널이라고 부른다.

독립 방식 → 서로 통합하지 않는 방식. 두 바운디드 컨텍스트 간에 통합하지 않으므로 서로 독립적으로 모델을 발전 시킨다. 독립 방식에서 두 바운디드 컨텍스트 간의 통합은 수동으로 이루어지는 경우도 있다.

온라인 쇼핑몰에서 외부 ERP 연동이 지원되지 않아 직접 수동으로 ERP 시스템에 입력하는 경우.
(규모가 커지면 별도의 시스템이 필요하게 된다.)

### 컨텍스트 맵

컨텍스트에 관해 나무를 보고 숲을 보지 못하는 경우를 방지하기 위해서 전체 비즈니스를 볼수 있는 지도가 컨택스트 맵이다. (바운디드 컨텍스트간의 관계를 표시한다.)